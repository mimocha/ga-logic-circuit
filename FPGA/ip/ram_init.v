// megafunction wizard: %RAM initializer%
// GENERATION: STANDARD
// VERSION: WM1.0
// MODULE: ALTMEM_INIT 

// ============================================================
// File Name: ram_init.v
// Megafunction Name(s):
// 			ALTMEM_INIT
//
// Simulation Library Files(s):
// 			lpm
// ============================================================
// ************************************************************
// THIS IS A WIZARD-GENERATED FILE. DO NOT EDIT THIS FILE!
//
// 18.0.0 Build 614 04/24/2018 SJ Lite Edition
// ************************************************************


//Copyright (C) 2018  Intel Corporation. All rights reserved.
//Your use of Intel Corporation's design tools, logic functions 
//and other software and tools, and its AMPP partner logic 
//functions, and any output files from any of the foregoing 
//(including device programming or simulation files), and any 
//associated documentation or information are expressly subject 
//to the terms and conditions of the Intel Program License 
//Subscription Agreement, the Intel Quartus Prime License Agreement,
//the Intel FPGA IP License Agreement, or other applicable license
//agreement, including, without limitation, that your use is for
//the sole purpose of programming logic devices manufactured by
//Intel and sold by Intel or its authorized distributors.  Please
//refer to the applicable agreement for further details.


//altmem_init CBX_AUTO_BLACKBOX="ALL" DEVICE_FAMILY="Cyclone V" INIT_TO_ZERO="YES" NUMWORDS=256 PORT_ROM_DATA_READY="PORT_UNUSED" ROM_READ_LATENCY=1 WIDTH=8 WIDTHAD=8 clock dataout init init_busy ram_address ram_wren
//VERSION_BEGIN 18.0 cbx_altera_syncram_nd_impl 2018:04:24:18:04:18:SJ cbx_altmem_init 2018:04:24:18:04:18:SJ cbx_altsyncram 2018:04:24:18:04:18:SJ cbx_cycloneii 2018:04:24:18:04:18:SJ cbx_lpm_add_sub 2018:04:24:18:04:18:SJ cbx_lpm_compare 2018:04:24:18:04:18:SJ cbx_lpm_counter 2018:04:24:18:04:18:SJ cbx_lpm_decode 2018:04:24:18:04:18:SJ cbx_lpm_mux 2018:04:24:18:04:18:SJ cbx_mgl 2018:04:24:18:08:49:SJ cbx_nadder 2018:04:24:18:04:18:SJ cbx_stratix 2018:04:24:18:04:18:SJ cbx_stratixii 2018:04:24:18:04:18:SJ cbx_stratixiii 2018:04:24:18:04:18:SJ cbx_stratixv 2018:04:24:18:04:18:SJ cbx_util_mgl 2018:04:24:18:04:18:SJ  VERSION_END
// synthesis VERILOG_INPUT_VERSION VERILOG_2001
// altera message_off 10463


//synthesis_resources = lpm_compare 2 lpm_counter 2 reg 5 
//synopsys translate_off
`timescale 1 ps / 1 ps
//synopsys translate_on
module  ram_init_meminit_h0k
	( 
	clock,
	dataout,
	init,
	init_busy,
	ram_address,
	ram_wren) ;
	input   clock;
	output   [7:0]  dataout;
	input   init;
	output   init_busy;
	output   [7:0]  ram_address;
	output   ram_wren;

	reg	[0:0]	capture_init;
	reg	[1:0]	prev_state;
	wire	[1:0]	wire_state_reg_d;
	reg	[1:0]	state_reg;
	wire	[1:0]	wire_state_reg_sclr;
	wire	[1:0]	wire_state_reg_sload;
	wire  wire_addr_cmpr_aeb;
	wire  wire_addr_cmpr_alb;
	wire  wire_wait_cmpr_aeb;
	wire  wire_wait_cmpr_alb;
	wire  [7:0]   wire_addr_ctr_q;
	wire  [0:0]   wire_wait_ctr_q;
	wire  [0:0]  addrct_eq_numwords;
	wire  [0:0]  addrct_lt_numwords;
	wire clken;
	wire  [0:0]  done_state;
	wire  [0:0]  idle_state;
	wire  [0:0]  ram_addr_state;
	wire  [0:0]  ram_write_state;
	wire  [0:0]  reset_state_machine;
	wire  [0:0]  state_machine_clken;
	wire  [0:0]  waitct_eq_latency;
	wire  [0:0]  waitct_lt_latency;

	// synopsys translate_off
	initial
		capture_init = 0;
	// synopsys translate_on
	always @ ( posedge clock)
		if (clken == 1'b1)   capture_init <= ((init | capture_init) & (~ done_state));
	// synopsys translate_off
	initial
		prev_state = 0;
	// synopsys translate_on
	always @ ( posedge clock)
		if (clken == 1'b1)   prev_state <= state_reg;
	// synopsys translate_off
	initial
		state_reg[0:0] = 0;
	// synopsys translate_on
	always @ ( posedge clock)
		if (state_machine_clken == 1'b1) 
			if (wire_state_reg_sclr[0:0] == 1'b1) state_reg[0:0] <= 1'b0;
			else if (wire_state_reg_sload[0:0] == 1'b1) state_reg[0:0] <= 1;
			else  state_reg[0:0] <= wire_state_reg_d[0:0];
	// synopsys translate_off
	initial
		state_reg[1:1] = 0;
	// synopsys translate_on
	always @ ( posedge clock)
		if (state_machine_clken == 1'b1) 
			if (wire_state_reg_sclr[1:1] == 1'b1) state_reg[1:1] <= 1'b0;
			else if (wire_state_reg_sload[1:1] == 1'b1) state_reg[1:1] <= 1;
			else  state_reg[1:1] <= wire_state_reg_d[1:1];
	assign
		wire_state_reg_d = {(state_reg[1] ^ state_reg[0]), (~ state_reg[0])};
	assign
		wire_state_reg_sclr = {reset_state_machine, 1'b0},
		wire_state_reg_sload = {1'b0, reset_state_machine};
	lpm_compare   addr_cmpr
	( 
	.aeb(wire_addr_cmpr_aeb),
	.agb(),
	.ageb(),
	.alb(wire_addr_cmpr_alb),
	.aleb(),
	.aneb(),
	.dataa(wire_addr_ctr_q),
	.datab({8{1'b1}})
	`ifndef FORMAL_VERIFICATION
	// synopsys translate_off
	`endif
	,
	.aclr(1'b0),
	.clken(1'b1),
	.clock(1'b0)
	`ifndef FORMAL_VERIFICATION
	// synopsys translate_on
	`endif
	);
	defparam
		addr_cmpr.lpm_width = 8,
		addr_cmpr.lpm_type = "lpm_compare";
	lpm_compare   wait_cmpr
	( 
	.aeb(wire_wait_cmpr_aeb),
	.agb(),
	.ageb(),
	.alb(wire_wait_cmpr_alb),
	.aleb(),
	.aneb(),
	.dataa(wire_wait_ctr_q),
	.datab(1'b0)
	`ifndef FORMAL_VERIFICATION
	// synopsys translate_off
	`endif
	,
	.aclr(1'b0),
	.clken(1'b1),
	.clock(1'b0)
	`ifndef FORMAL_VERIFICATION
	// synopsys translate_on
	`endif
	);
	defparam
		wait_cmpr.lpm_width = 1,
		wait_cmpr.lpm_type = "lpm_compare";
	lpm_counter   addr_ctr
	( 
	.clk_en(clken),
	.clock(clock),
	.cnt_en((prev_state[1] & (~ prev_state[0]))),
	.cout(),
	.eq(),
	.q(wire_addr_ctr_q),
	.sclr(idle_state)
	`ifndef FORMAL_VERIFICATION
	// synopsys translate_off
	`endif
	,
	.aclr(1'b0),
	.aload(1'b0),
	.aset(1'b0),
	.cin(1'b1),
	.data({8{1'b0}}),
	.sload(1'b0),
	.sset(1'b0),
	.updown(1'b1)
	`ifndef FORMAL_VERIFICATION
	// synopsys translate_on
	`endif
	);
	defparam
		addr_ctr.lpm_direction = "UP",
		addr_ctr.lpm_modulus = 256,
		addr_ctr.lpm_port_updown = "PORT_UNUSED",
		addr_ctr.lpm_width = 8,
		addr_ctr.lpm_type = "lpm_counter";
	lpm_counter   wait_ctr
	( 
	.clk_en(clken),
	.clock(clock),
	.cnt_en(ram_addr_state),
	.cout(),
	.eq(),
	.q(wire_wait_ctr_q),
	.sclr((~ ram_addr_state))
	`ifndef FORMAL_VERIFICATION
	// synopsys translate_off
	`endif
	,
	.aclr(1'b0),
	.aload(1'b0),
	.aset(1'b0),
	.cin(1'b1),
	.data({1{1'b0}}),
	.sload(1'b0),
	.sset(1'b0),
	.updown(1'b1)
	`ifndef FORMAL_VERIFICATION
	// synopsys translate_on
	`endif
	);
	defparam
		wait_ctr.lpm_direction = "UP",
		wait_ctr.lpm_modulus = 1,
		wait_ctr.lpm_port_updown = "PORT_UNUSED",
		wait_ctr.lpm_width = 1,
		wait_ctr.lpm_type = "lpm_counter";
	assign
		addrct_eq_numwords = wire_addr_cmpr_aeb,
		addrct_lt_numwords = wire_addr_cmpr_alb,
		clken = 1'b1,
		dataout = {8{1'b0}},
		done_state = (state_reg[1] & state_reg[0]),
		idle_state = ((~ state_reg[1]) & (~ state_reg[0])),
		init_busy = capture_init,
		ram_addr_state = ((~ state_reg[1]) & state_reg[0]),
		ram_address = wire_addr_ctr_q,
		ram_wren = ((~ prev_state[1]) & prev_state[0]),
		ram_write_state = (state_reg[1] & (~ state_reg[0])),
		reset_state_machine = (ram_write_state & addrct_lt_numwords),
		state_machine_clken = (clken & (((idle_state & capture_init) | (done_state & waitct_eq_latency)) | (capture_init & (((~ (ram_addr_state & waitct_lt_latency)) | (ram_addr_state & waitct_eq_latency)) | (ram_write_state & addrct_eq_numwords))))),
		waitct_eq_latency = wire_wait_cmpr_aeb,
		waitct_lt_latency = wire_wait_cmpr_alb;
endmodule //ram_init_meminit_h0k
//VALID FILE


// synopsys translate_off
`timescale 1 ps / 1 ps
// synopsys translate_on
module ram_init (
	clock,
	init,
	dataout,
	init_busy,
	ram_address,
	ram_wren);

	input	  clock;
	input	  init;
	output	[7:0]  dataout;
	output	  init_busy;
	output	[7:0]  ram_address;
	output	  ram_wren;

	wire [7:0] sub_wire0;
	wire  sub_wire1;
	wire [7:0] sub_wire2;
	wire  sub_wire3;
	wire [7:0] dataout = sub_wire0[7:0];
	wire  init_busy = sub_wire1;
	wire [7:0] ram_address = sub_wire2[7:0];
	wire  ram_wren = sub_wire3;

	ram_init_meminit_h0k	ram_init_meminit_h0k_component (
				.clock (clock),
				.init (init),
				.dataout (sub_wire0),
				.init_busy (sub_wire1),
				.ram_address (sub_wire2),
				.ram_wren (sub_wire3));

endmodule

// ============================================================
// CNX file retrieval info
// ============================================================
// Retrieval info: LIBRARY: altera_mf altera_mf.altera_mf_components.all
// Retrieval info: PRIVATE: INTENDED_DEVICE_FAMILY STRING "Cyclone V"
// Retrieval info: CONSTANT: INIT_FILE STRING "UNUSED"
// Retrieval info: CONSTANT: INIT_TO_ZERO STRING "YES"
// Retrieval info: CONSTANT: INTENDED_DEVICE_FAMILY STRING "Cyclone V"
// Retrieval info: CONSTANT: LPM_HINT STRING "UNUSED"
// Retrieval info: CONSTANT: LPM_TYPE STRING "altmem_init"
// Retrieval info: CONSTANT: NUMWORDS NUMERIC "256"
// Retrieval info: CONSTANT: PORT_ROM_DATA_READY STRING "PORT_UNUSED"
// Retrieval info: CONSTANT: ROM_READ_LATENCY NUMERIC "1"
// Retrieval info: CONSTANT: WIDTH NUMERIC "8"
// Retrieval info: CONSTANT: WIDTHAD NUMERIC "8"
// Retrieval info: USED_PORT: clock 0 0 0 0 INPUT NODEFVAL "clock"
// Retrieval info: CONNECT: @clock 0 0 0 0 clock 0 0 0 0
// Retrieval info: USED_PORT: dataout 0 0 8 0 OUTPUT NODEFVAL "dataout[7..0]"
// Retrieval info: CONNECT: dataout 0 0 8 0 @dataout 0 0 8 0
// Retrieval info: USED_PORT: init 0 0 0 0 INPUT NODEFVAL "init"
// Retrieval info: CONNECT: @init 0 0 0 0 init 0 0 0 0
// Retrieval info: USED_PORT: init_busy 0 0 0 0 OUTPUT NODEFVAL "init_busy"
// Retrieval info: CONNECT: init_busy 0 0 0 0 @init_busy 0 0 0 0
// Retrieval info: USED_PORT: ram_address 0 0 8 0 OUTPUT NODEFVAL "ram_address[7..0]"
// Retrieval info: CONNECT: ram_address 0 0 8 0 @ram_address 0 0 8 0
// Retrieval info: USED_PORT: ram_wren 0 0 0 0 OUTPUT NODEFVAL "ram_wren"
// Retrieval info: CONNECT: ram_wren 0 0 0 0 @ram_wren 0 0 0 0
// Retrieval info: GEN_FILE: TYPE_NORMAL ram_init.v TRUE FALSE
// Retrieval info: GEN_FILE: TYPE_NORMAL ram_init.qip TRUE FALSE
// Retrieval info: GEN_FILE: TYPE_NORMAL ram_init.bsf FALSE TRUE
// Retrieval info: GEN_FILE: TYPE_NORMAL ram_init_inst.v TRUE TRUE
// Retrieval info: GEN_FILE: TYPE_NORMAL ram_init_bb.v FALSE TRUE
// Retrieval info: GEN_FILE: TYPE_NORMAL ram_init.inc FALSE TRUE
// Retrieval info: GEN_FILE: TYPE_NORMAL ram_init.cmp FALSE TRUE
// Retrieval info: LIB_FILE: lpm
